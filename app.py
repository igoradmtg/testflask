# -*- coding: utf-8 -*-

# --- Импорт необходимых библиотек ---
# Flask - это основной класс фреймворка, который мы используем для создания нашего приложения.
# url_for - функция для построения URL-адресов для конкретных функций. Это удобно, чтобы не прописывать URL вручную.
# render_template - функция для отрисовки HTML-шаблонов. Она ищет шаблоны в папке 'templates'.
# jsonify - функция для преобразования словарей Python в JSON-ответ.
from flask import Flask, url_for, render_template, jsonify

# --- Инициализация приложения ---
# Создаем экземпляр нашего веб-приложения.
# __name__ - это специальная переменная Python, которая получает имя текущего модуля (в данном случае "app").
# Flask использует это имя, чтобы знать, где искать ресурсы, такие как шаблоны и статические файлы.
app = Flask(__name__)


# --- Маршруты (URL-адреса) приложения ---

# Маршрут для главной страницы ("/")
# @app.route() - это декоратор, который связывает URL-адрес с функцией.
# Когда кто-то заходит на главную страницу сайта, Flask вызывает функцию start_page().
@app.route("/")
def start_page():
    """
    Эта функция отображает стартовую страницу.
    Возвращает:
        str: Простое текстовое приветствие.
    """
    return "Start!"

# Маршрут для страницы "/index"
@app.route('/index')
def index():
    """
    Эта функция отображает страницу 'Index'.
    Возвращает:
        str: Текст "Index Page".
    """
    return 'Index Page'
    
# Маршрут для страницы "/status"
@app.route('/status')
def status():
    """
    Эта функция отображает статус.
    Возвращает:
        str: Сообщение о том, что приложение сделано на Flask.
    """
    return "Сделано на flask"
    
# Динамический маршрут для профиля пользователя.
# <username> - это переменная часть URL. Все, что будет вписано после /user/,
# передастся в функцию show_user_profile в качестве аргумента `username`.
@app.route('/user/<username>')
def show_user_profile(username):
    """
    Эта функция отображает профиль конкретного пользователя.
    Аргументы:
        username (str): Имя пользователя, полученное из URL.
    Возвращает:
        str: Строка, приветствующая пользователя по имени.
    """
    # Мы используем f-строку для форматирования. Это современный и удобный способ.
    return f'Профиль пользователя: {username}'

# Динамический маршрут для отображения поста по его ID.
# <int:post_id> означает, что эта часть URL будет преобразована в целое число (integer).
# Если ввести не число, Flask вернет ошибку 404 (страница не найдена).
@app.route('/post/<int:post_id>')
def show_post(post_id):
    """
    Эта функция отображает пост по его числовому идентификатору.
    Аргументы:
        post_id (int): ID поста, полученный из URL.
    Возвращает:
        str: Строка, отображающая номер поста.
    """
    return f'Пост номер: {post_id}'

# Маршрут для страницы проектов. Слеш в конце важен: Flask будет автоматически
# перенаправлять с /projects на /projects/, если пользователь его забудет.
@app.route('/projects/')
def projects():
    """
    Эта функция отображает страницу проектов.
    Возвращает:
        str: Текст "The project page".
    """
    return 'The project page'
    
# Маршрут, который может принимать необязательный параметр.
# Он будет работать для /hello/ и для /hello/<name>
@app.route('/hello/')
@app.route('/hello/<name>')
def hello(name=None):
    """
    Эта функция приветствует пользователя по имени, используя HTML-шаблон.
    Если имя не указано, оно будет None.
    Аргументы:
        name (str, optional): Имя для приветствия. По умолчанию None.
    Возвращает:
        str: Отрисованный HTML-шаблон 'hello.html'.
    """
    # Передаем переменную `name` в шаблон 'hello.html'.
    return render_template('hello.html', name=name)

# Маршрут, демонстрирующий использование функции url_for.
@app.route('/url')
def url():
    """
    Эта функция показывает, как генерировать URL-адреса для других функций (маршрутов).
    Это очень полезно, т.к. если вы измените URL в @app.route, вам не придется менять его во всем коде.
    Возвращает:
        str: HTML-код с сгенерированными ссылками.
    """
    # Генерируем URL для функции `show_user_profile` с параметром username='Papa igor'
    user_url = url_for('show_user_profile', username='Papa igor')
    
    # Генерируем URL для функции `status`
    status_url = url_for('status')
    
    # Генерируем URL для функции `projects`
    projects_url = url_for('projects')
    
    # Собираем все в один HTML-ответ.
    text = f"URL для профиля 'Papa igor': {user_url}<br>"
    text += f"URL для статуса: {status_url}<br>"
    text += f"URL для проектов: {projects_url}"
    return text

# --- Новые функции, добавленные для улучшения ---

# 1. Новая страница "О нас"
@app.route('/about')
def about():
    """
    Новая функция для страницы "О нас".
    Возвращает:
        str: Информация о приложении.
    """
    return 'Это простое демонстрационное приложение на Flask!'

# 2. Новая страница со списком элементов (товаров)
@app.route('/products')
def show_products():
    """
    Новая функция, которая отображает список товаров, используя HTML-шаблон.
    Это демонстрирует передачу списка в шаблон и использование цикла в нем.
    """
    # Создаем список товаров. В реальном приложении эти данные приходили бы из базы данных.
    product_list = ['Яблоки', 'Апельсины', 'Бананы', 'Кофе', 'Чай']
    # Отрисовываем шаблон 'products.html' и передаем в него наш список.
    return render_template('products.html', products=product_list)

# 3. Новый API-эндпоинт для получения данных в формате JSON
@app.route('/api/data')
def get_data():
    """
    Новая функция, которая работает как API. Она возвращает данные в формате JSON.
    Это очень полезно для взаимодействия с JavaScript-фронтендом или другими программами.
    """
    # Создаем словарь с данными.
    data = {
        'version': '1.0',
        'status': 'ok',
        'data': [
            {'id': 1, 'name': 'Пользователь 1'},
            {'id': 2, 'name': 'Пользователь 2'}
        ]
    }
    # Используем jsonify для корректного преобразования словаря в JSON-ответ.
    return jsonify(data)

# --- Обработка ошибок ---

# Обработчик для ошибки 404 (Страница не найдена)
@app.errorhandler(404)
def page_not_found(error):
    """
    Эта функция вызывается автоматически, когда Flask не может найти запрошенный URL.
    Она возвращает кастомную страницу 404.
    """
    # Возвращаем наш HTML-шаблон и код состояния 404.
    return render_template('404.html'), 404

# --- Запуск приложения ---
# Условие `if __name__ == "__main__":` означает, что код внутри этого блока
# будет выполнен только тогда, когда этот файл запускается напрямую (а не импортируется как модуль).
if __name__ == "__main__":
    # app.run() запускает локальный веб-сервер.
    # debug=True включает режим отладки: сервер будет автоматически перезапускаться при изменениях в коде,
    # а в браузере будут отображаться подробные сообщения об ошибках.
    # ВАЖНО: Никогда не используйте debug=True в реальном, рабочем приложении!
    app.run(debug=True)
